grammar Gram;
// Parser Rules
statement: ifStmt | initListStmt | initElemStmt | initValStmt | mathStmt | onVarStmt | printStmt | saveDocStmt | whileStmt ;
ifStmt: IF LNBRACKET expression RNBRACKET LCBRACKET (statement)+ RCBRACKET ( ELSE LCBRACKET (statement)+ RCBRACKET )? ;
whileStmt: WHILE LNBRACKET expression RNBRACKET LCBRACKET (statement)+ RCBRACKET ;
mathStmt: VARNAME ASSIGNOP numberArgument MATHOP numberArgument SEMICOLON ;
saveDocStmt: SAVE LNBRACKET VARNAME COMMA textArgument RNBRACKET SEMICOLON ;
printStmt: PRINT LNBRACKET textArgument RNBRACKET SEMICOLON ;
initListStmt: LISTVAR VARNAME ASSIGNOP ( initListFun | VARNAME ) ( ( modListFun )+ | ( filterFun )+ )? SEMICOLON ;
onVarStmt: VARNAME (LSBRACKET numberArgument RSBRACKET)? onVarFun SEMICOLON ;
onVarFun: ( modListFun )+ | ( filterFun )+ | ( modAttrFun )+ | getAttrFun | sizeFun ;
initListFun: createFun | readFun ;
createFun: CREATE LNBRACKET ( VARNAME )? RNBRACKET ;
readFun: READ LNBRACKET textArgument RNBRACKET ;
filterFun: filterAttrFun | filterTagFun ;
filterAttrFun: EXOP FILTERBYATTR LNBRACKET textArgument COMMA argument RNBRACKET ;
filterTagFun: EXOP FILTERBYTAG LNBRACKET textArgument RNBRACKET ;
modListFun: EXOP MODLISTOP LNBRACKET VARNAME RNBRACKET ;
sizeFun: EXOP SIZE LNBRACKET RNBRACKET ;
initElemStmt: ELEMVAR VARNAME ASSIGNOP  initElemFun ( setAttrFun )? SEMICOLON ;
initElemFun: createElemFun | getElemFun ;
createElemFun: CREATE LNBRACKET textArgument RNBRACKET ;
getElemFun: VARNAME LSBRACKET numberArgument RSBRACKET ;
modAttrFun: setAttrFun | deleteAttrFun ;
setAttrFun: EXOP SETATTR LNBRACKET textArgument COMMA argument RNBRACKET ;
deleteAttrFun: EXOP DELETEATTR LNBRACKET textArgument RNBRACKET ;
getAttrFun: EXOP GETATTR LNBRACKET textArgument RNBRACKET ;
initValStmt: VALVAR VARNAME ASSIGNOP ( argument | ( numberArgument MATHOP numberArgument) |  VARNAME sizeFun) SEMICOLON ;
expression: numberArgument EXPRESSIONOP numberArgument ( ANDOP numberArgument EXPRESSIONOP numberArgument )* ;
textArgument: VARNAME | TEXT ;
numberArgument: VARNAME | NUMBER;
argument: textArgument | NUMBER;

// Lexer Rules
IF: 'if';
ELSE: 'else';
WHILE: 'while';
LCBRACKET: '{';
RCBRACKET: '}';
LNBRACKET: '(';
RNBRACKET: ')';
LSBRACKET: '[';
RSBRACKET: ']';
ASSIGNOP: '=';
EXPRESSIONOP: '<' | '>' | '<=' | '>=' | '==' | '!=';
MATHOP: '+' | '-' | '*' | '/' ;
ANDOP: '&&' | '||';
MODLISTOP: 'add' | 'remove' ;
EXOP: '.';
COMMA: ',';
SEMICOLON: ';';
GETATTR: 'getAttr';
SETATTR: 'setAttr';
DELETEATTR: 'deleteAttr';
SAVE: 'save';
READ: 'read';
PRINT: 'print';
CREATE: 'create';
SIZE: 'size';
FILTERBYATTR: 'filterByAttr';
FILTERBYTAG: 'filterByTag';
VALVAR: 'val';
LISTVAR: 'list';
ELEMVAR: 'elem';
NUMBER: ('0'|'-'?[1-9][0-9]*);
VARNAME: [a-zA-Z]([a-zA-Z]|NUMBER)*;
TEXT: '"'.+?'"';
